---
alwaysApply: false
---

# üéØ **GENERAL RULES: Smarty to Next.js Migration Project Standards**


## üìã **RULE #1: PRE-IMPLEMENTATION ANALYSIS (MANDATORY)**

### **Before writing ANY code:**
```bash
# ‚úÖ STEP 1: Read project structure
1. Analyze existing similar components in /components/jobseekers/
2. Check /types/jobseekers/ for existing interfaces
3. Review /hooks/jobseekers/ for reusable hooks
4. Examine /libs/api/jobseekers/ for API patterns
5. Study /styles/jobseekers/ for CSS organization
```

### **Component Analysis Checklist:**
- [ ] **Interactive elements** ‚Üí Client Component required
- [ ] **Static content only** ‚Üí Server Component sufficient
- [ ] **Data fetching needs** ‚Üí SWR hook required
- [ ] **Multi-selection** ‚Üí useMultiSelect integration
- [ ] **Pagination** ‚Üí UIPagination integration
- [ ] **User actions** ‚Üí Dialog components needed

## üèóÔ∏è **RULE #2: ARCHITECTURE DECISION MATRIX**

### **Server Component (page.tsx) - Use when:**
- Static content rendering
- SEO-critical pages
- Layout and meta data
- Initial data fetching
- **NEVER**: Interactive functionality, hooks, event handlers

### **Client Component - Use when:**
- Form interactions
- Checkboxes, buttons with onClick
- State management (useState, useEffect)
- Real-time updates
- User feedback dialogs

### **Hybrid Pattern (RECOMMENDED):**
```typescript
// ‚úÖ Server Component (page.tsx)
export default async function FeaturePage() {
  const t = await getTranslations();
  // Layout + metadata only
  return (
    <FeatureWrapper>
      <ClientFeatureComponent />
    </FeatureWrapper>
  );
}

// ‚úÖ Client Component (separate file)
'use client';
export default function ClientFeatureComponent() {
  // All interactive functionality
}
```

## üìÅ **RULE #3: UNIVERSAL FILE STRUCTURE**

### **Mandatory Structure for ANY feature:**
```
src/
‚îú‚îÄ‚îÄ app/[locale]/(jobseekers)/path/to/feature/
‚îÇ   ‚îî‚îÄ‚îÄ page.tsx                           // Server Component only
‚îú‚îÄ‚îÄ components/jobseekers/dashboard/feature-name/
‚îÇ   ‚îú‚îÄ‚îÄ MainComponent.tsx                  // Primary Client Component
‚îÇ   ‚îú‚îÄ‚îÄ SubComponent1.tsx                  // Feature sub-components
‚îÇ   ‚îî‚îÄ‚îÄ utils.ts                          // Feature-specific utilities
‚îú‚îÄ‚îÄ hooks/jobseekers/feature-name/
‚îÇ   ‚îú‚îÄ‚îÄ useGetFeatureData.tsx             // Data fetching
‚îÇ   ‚îú‚îÄ‚îÄ useFeatureActions.tsx             // CRUD operations
‚îÇ   ‚îî‚îÄ‚îÄ useFeatureState.tsx               // Complex state logic
‚îú‚îÄ‚îÄ libs/api/jobseekers/feature-name/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                          // API class
‚îú‚îÄ‚îÄ types/jobseekers/feature-name/
‚îÇ   ‚îî‚îÄ‚îÄ index.ts                          // TypeScript interfaces
‚îî‚îÄ‚îÄ styles/jobseekers/feature-name/
    ‚îî‚îÄ‚îÄ feature.css                       // Feature-specific CSS
```

### **Naming Convention Rules:**
- **Folders**: `kebab-case` (feedback-employer, job-application)
- **Components**: `PascalCase.tsx` (FeedbackTable.tsx)
- **Hooks**: `camelCase.tsx` (useGetFeedback.tsx)
- **Types**: `interface PascalCase`
- **CSS**: `kebab-case.css`

## üîå **RULE #4: DATA INTEGRATION PATTERNS**

### **SWR Hook Template (MANDATORY):**
```typescript
// /hooks/jobseekers/{feature}/useGet{Feature}.tsx
import useSWR from 'swr';
import { JOBSEEKER_SWR_KEYS } from '@/constants/swr-keys/jobseekers';
import { FeatureApi } from '@/libs/api/jobseekers/{feature}';

export const useGetFeature = (params?: any) => {
  const { data, error, isLoading, mutate } = useSWR(
    [JOBSEEKER_SWR_KEYS.GET_FEATURE, params],
    () => FeatureApi.getData(params),
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: false,
    }
  );
  
  return { data, isLoading, isError: !!error, error, mutate };
};
```

### **API Class Template (MANDATORY):**
```typescript
// /libs/api/jobseekers/{feature}/index.ts
import { ApiResponse } from '@/types/jobseekers/api';
import { axiosInternal } from '@/libs/axios/axios';

export class FeatureApi {
  static getData = async (params: any): Promise<ApiResponse<DataType[]>> => {
    try {
      const res = await axiosInternal.get('/api/endpoint', { params });
      return res.data;
    } catch (error) {
      throw error;
    }
  };

  static createItem = async (data: CreateType): Promise<ApiResponse<DataType>> => {
    try {
      const res = await axiosInternal.post('/api/endpoint', data);
      return res.data;
    } catch (error) {
      throw error;
    }
  };

  static updateItem = async (id: string, data: UpdateType): Promise<ApiResponse<DataType>> => {
    try {
      const res = await axiosInternal.put(`/api/endpoint/${id}`, data);
      return res.data;
    } catch (error) {
      throw error;
    }
  };

  static deleteItem = async (id: string): Promise<ApiResponse<void>> => {
    try {
      const res = await axiosInternal.delete(`/api/endpoint/${id}`);
      return res.data;
    } catch (error) {
      throw error;
    }
  };
}
```

## üéÆ **RULE #5: STATE MANAGEMENT STANDARDS**

### **Multi-Selection (Checkboxes):**
```typescript
// ‚úÖ ALWAYS use existing hook
import { useMultiSelect } from '@/hooks/share/useMultiSelect';

const itemIds = data?.map(item => hexID(parseInt(item.ID))) || [];
const {
  selectedItems,
  handleCheckSingle,
  handleCheckAll,
  clearCheck,
  isEmpty,
  isAllChecked
} = useMultiSelect(itemIds);
```

### **URL State Management:**
```typescript
// ‚úÖ ALWAYS sync with URL for navigation states
import { useSearchParams, useRouter, usePathname } from 'next/navigation';

const searchParams = useSearchParams();
const router = useRouter();
const pathname = usePathname();

// Get params
const page = searchParams.get('page') || '1';
const filter = searchParams.get('filter') || '';

// Update params
const updateParams = (key: string, value: string) => {
  const params = new URLSearchParams(searchParams);
  if (value) {
    params.set(key, value);
  } else {
    params.delete(key);
  }
  router.push(`${pathname}?${params.toString()}`);
};
```

### **Form State:**
```typescript
// ‚úÖ Use react-hook-form for complex forms
import { useForm } from 'react-hook-form';

interface FormData {
  // Form fields
}

export default function FormComponent() {
  const { register, handleSubmit, formState: { errors } } = useForm<FormData>();
  
  const onSubmit = async (data: FormData) => {
    // Form submission logic
  };
}
```

## üé® **RULE #6: UI COMPONENT INTEGRATION**

### **Loading States (MANDATORY):**
```typescript
// ‚úÖ Tables
{isLoading ? (
  <SkeletonTable rows={5} columns={3} />
) : (
  <ActualTable />
)}

// ‚úÖ Lists
{isLoading ? (
  <SkeletonList items={5} />
) : (
  <ActualList />
)}

// ‚úÖ Cards
{isLoading ? (
  <SkeletonCard />
) : (
  <ActualCard />
)}
```

### **Pagination (MANDATORY):**
```typescript
import { UIPagination, createPageObject } from '@/components/UI/pagination/UIPagination';

// Create page object
const pageObject = createPageObject(
  totalItems,
  itemsPerPage,
  currentPage
);

// Render pagination
<UIPagination
  pageObject={pageObject}
  basePath={`/${locale}/feature/path`}
  mapKeys={{ page: 'page' }}
  showFirstLastNav={true}
/>
```

### **Dialogs (MANDATORY for actions):**
```typescript
import { ConfirmationDialog } from '@/components/UI/dialog/notice/ConfirmDialog';
import { NoticeDialog } from '@/components/UI/dialog/notice/NoticeDialog';

// State management
const [openConfirm, setOpenConfirm] = useState(false);
const [openNotice, setOpenNotice] = useState(false);
const [message, setMessage] = useState('');

// Confirmation dialog
<ConfirmationDialog 
  open={openConfirm}
  onClose={() => setOpenConfirm(false)}
  onConfirm={handleConfirm}
  loading={isProcessing}
  title={t('confirm_title')}
  message={message}
/>

// Notice dialog
<NoticeDialog 
  open={openNotice}
  onClose={() => setOpenNotice(false)}
  message={message}
/>
```

## üîß **RULE #7: UTILITY INTEGRATION**

### **Required Utility Imports:**
```typescript
// ‚úÖ ALWAYS import from /utils
import { 
  hexID,           // ID conversion
  createJobUrl,    // URL slug creation  
  bitToArray,      // Contact visibility
  formatMoney,     // Money formatting
  createTitleUrl   // Title to URL
} from '@/utils';
```

### **Image Handling Standard:**
```typescript
import Image from 'next/image';
import DefaultImage from '@/assets/img/jobseekers/default-image.png';

// ‚úÖ ALWAYS with fallback
<Image 
  src={item.imageUrl || DefaultImage} 
  alt={item.title || 'Default alt'} 
  width={requiredWidth}
  height={requiredHeight}
  priority={false}
/>
```

### **Contact Visibility Logic:**
```typescript
// ‚úÖ STANDARD pattern for contact bits
const contactBits = bitToArray(item.CONTACT_HIDE || '00000000') || [];
const contactBitsMap: Record<number, string> = {};
contactBits.forEach((bit, index) => {
  contactBitsMap[index + 1] = bit;
});

const isContactHidden = contactBitsMap[1] === '1' || contactBitsMap[2] === '1';
const isClientHidden = contactBitsMap[7] === '1';

// Display logic
let displayName = item.NAME;
if (isContactHidden) {
  displayName = isClientHidden 
    ? t('common_hide_infomation_client')
    : t('common_hide_contact');
}
```

## üìù **RULE #8: TYPESCRIPT STANDARDS**

### **Interface Definition Rules:**
```typescript
// ‚úÖ /types/jobseekers/{feature}/index.ts
export interface MainDataInterface {
  ID: string;                    // ALWAYS string for IDs
  NAME: string;
  CREATED_DATE: string;          // ISO date strings
  STATUS: number;                // Status as numbers
  // Use EXACT backend field names
}

export interface CreateInterface {
  name: string;
  // Only fields needed for creation
}

export interface UpdateInterface extends Partial<CreateInterface> {
  id: string;
  // Only updatable fields
}

export interface ApiResponseInterface extends ApiResponse<MainDataInterface[]> {
  metadata?: {
    itemCount: number;
    totalPages: number;
    currentPage: number;
  };
}
```

### **Component Props Interface:**
```typescript
interface ComponentProps {
  data?: MainDataInterface[];
  isLoading?: boolean;
  onAction?: (id: string) => void;
  // Optional props with defaults
}

export default function Component({ 
  data = [], 
  isLoading = false,
  onAction 
}: ComponentProps) {
  // Component logic
}
```

## üåê **RULE #9: TRANSLATION INTEGRATION**

### **Translation Patterns:**
```typescript
// ‚úÖ Client components
import { useTranslations, useLocale } from 'next-intl';
const t = useTranslations();
const locale = useLocale();

// ‚úÖ Server components  
import { getTranslations, getLocale } from 'next-intl/server';
const t = await getTranslations();
const locale = await getLocale();

// ‚úÖ Text content
{t('translation_key')}

// ‚úÖ HTML content
import parse from 'html-react-parser';
{parse(t.raw('key_with_html'))}

// ‚úÖ Dynamic content
{t('welcome_message', { name: user.name })}
```

### **Locale-specific Logic:**
```typescript
// ‚úÖ URL generation with locale
const generateUrl = (path: string) => `/${locale}${path}`;

// ‚úÖ Conditional content by locale
{locale === 'vi' ? 'Vietnamese content' : 'English content'}
```

## üö® **RULE #10: ERROR HANDLING & USER FEEDBACK**

### **Standard Error Handling:**
```typescript
const executeAction = async (actionData: any) => {
  setIsProcessing(true);
  try {
    await FeatureApi.performAction(actionData);
    
    // ‚úÖ Refresh data
    mutate(JOBSEEKER_SWR_KEYS.GET_FEATURE_DATA);
    
    // ‚úÖ Success feedback
    setOpenNotice(true);
    setMessage(t('action_success_message'));
    
  } catch (error: any) {
    // ‚úÖ Error feedback
    setOpenNotice(true);
    setMessage(error?.message || t('action_error_message'));
    
  } finally {
    setIsProcessing(false);
  }
};
```

### **Loading State Management:**
```typescript
// ‚úÖ Global loading states
const [isProcessing, setIsProcessing] = useState(false);
const [isDeleting, setIsDeleting] = useState(false);
const [isCreating, setIsCreating] = useState(false);

// ‚úÖ Disable interactions during loading
<button 
  onClick={handleAction}
  disabled={isProcessing}
>
  {isProcessing ? t('processing') : t('action_button')}
</button>
```

## üéØ **RULE #11: SMARTY CONVERSION PATTERNS**

### **Variable Conversion Map:**
```typescript
// Smarty ‚Üí TypeScript
{$variable}                    ‚Üí data?.variable
{$array|count}                ‚Üí array?.length || 0
{$array|@count > 0}           ‚Üí array && array.length > 0
{if $condition}...{/if}       ‚Üí {condition && (...)}
{foreach $array as $item}     ‚Üí array?.map((item, index) => (...))
{$smarty.const.CONSTANT}      ‚Üí CONSTANT (import from constants)
{$item.FIELD|escape}          ‚Üí item.FIELD (auto-escaped in React)
{$item.FIELD|nl2br}           ‚Üí item.FIELD?.replace(/\n/g, '<br>')
```

### **Template Structure Conversion:**
```typescript
// ‚úÖ Preserve HTML structure exactly
// Smarty:
<div class="widget widget-10">
  <div class="widget-head">
    <h3>{$title}</h3>
  </div>
</div>

// React:
<div className="widget widget-10">
  <div className="widget-head">
    <h3>{title}</h3>
  </div>
</div>
```

## üöÄ **RULE #12: DEPLOYMENT CHECKLIST**

### **Before marking task complete:**
- [ ] **Structure**: Files in correct locations
- [ ] **TypeScript**: No errors, proper interfaces
- [ ] **Translation**: All text externalized
- [ ] **Loading**: Skeleton states implemented
- [ ] **Error**: Proper error handling
- [ ] **Responsive**: Mobile-friendly
- [ ] **Accessibility**: Proper ARIA labels
- [ ] **Performance**: No unnecessary re-renders
- [ ] **SEO**: Proper meta data (if server component)
- [ ] **Testing**: Manual testing completed

### **Code Quality Gates:**
- [ ] ESLint passes
- [ ] TypeScript strict mode passes
- [ ] No console.errors in browser
- [ ] Proper error boundaries
- [ ] SWR mutations after data changes
- [ ] URL state properly managed
- [ ] Mobile responsive design

**These universal rules ensure consistency across ALL Smarty to Next.js migration tasks in the project.**